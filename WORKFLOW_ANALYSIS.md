# VF-Core-ActivateDeactivateIdentity Workflow Analysis

## Overview
This document explains how the VF-Core-ActivateDeactivateIdentity workflow works in the UI and why programmatic testing faces challenges.

---

## How It Works in the UI

### 1. **User Clicks QuickLink** (`QuickLink-VF-Core-ActivateDeactivateIdentity.xml`)

The QuickLink is configured with `action="workflow"` and launches the workflow with these parameters extracted from the JSF/web context:

```xml
<entry key="httpSession">
  - Extracts: FacesContext.getCurrentInstance().getExternalContext().getSession(true)
  - Returns: Real HTTP session object from Tomcat
```

```xml
<entry key="userLocale">
  - Extracts: request.getLocale() from HttpServletRequest
  - Returns: User's browser locale (e.g., en_US)
```

```xml
<entry key="clientTimeZone">
  - Extracts: Calendar.getInstance(userLocale).getTimeZone()
  - Returns: User's timezone from browser
```

```xml
<entry key="workflowName" value="VF-Core-ActivateDeactivateIdentity"/>
```

**KEY INSIGHT**: These parameters are AUTOMATICALLY extracted from the **JSF FacesContext** and **HTTP Servlet Container** - they cannot be manually created in standalone test code!

---

### 2. **Workflow Launches** (`Workflow-VF-Core-ActivateDeactivateIdentity.xml`)

#### Step 1: Initialize
```xml
<Step name="Initialize">
  - Sets up maModel HashMap with launcher, identityName, locale info
  - Requires: launcher, userLocale, clientTimeZone
```

#### Step 2: Show Request Initiate Form (LINE 85)
```xml
<Step name="Show Request Initiate Form">
  <Approval mode="serial" owner="ref:launcher">
    <Arg name="workItemType" value="Form"/>
    <Arg name="workItemForm" value="VF-Core-ActivateDeactivateIdentity-RequestInitiate"/>
  </Approval>
```

**What Happens in UI:**
1. SailPoint creates a **WorkItem** in the database
2. WorkItem is displayed in "My Work" for the launcher
3. User fills form:
   - operation: "Activate" or "Deactivate"
   - sponsorScope: "Local Market" or "Service"
   - vfMarket: "Vodafone Limited", etc.
   - requestees: [List of user IDs to activate/deactivate]
   - action: "individual" (hidden field)
4. User clicks "Next" → Form data saved to `maModel`
5. Workflow transitions to "Show Request Submit Form"

**What Happens Programmatically:**
1. Workflow launches via `Workflower.launch()`
2. WorkItem is created in **MEMORY ONLY** (transient)
3. WorkItem is NOT persisted to database
4. `workItemHandler.waitForWorkItem()` searches database → finds NULL
5. **TEST FAILS** ❌

---

#### Step 3: Show Request Submit Form (LINE 95)
```xml
<Step name="Show Request Submit Form">
  <Approval owner="ref:launcher">
    <Arg name="workItemForm" value="VF-Core-ActivateDeactivateIdentity-RequestSubmit"/>
  </Approval>
```

**What Happens in UI:**
1. Second WorkItem created
2. User provides:
   - busJustification: "Business reason for activation"
   - navigator: "vfsummary" (to proceed) or "vfcancel" (to cancel)
3. User clicks "Submit"
4. Workflow transitions to "Build Rio Plan"

---

#### Step 4: Build Rio Plan (LINE 119)
```xml
<Step name="Build Rio Plan">
  <Script>
    // Extracts data from maModel
    String operation = maModel.get("operation");  // "Activate" or "Deactivate"
    List requestees = maModel.get("requestees");  // User IDs
    String marketSelected = maModel.get("vfMarket");

    // For each user in requestees:
    for (String requestee : requestees) {
      Identity identity = context.getObjectByName(Identity.class, requestee);

      // Create workflow variables
      Map wfVariables = new HashMap();
      wfVariables.put("identityName", requestee);
      wfVariables.put("plan", provisioningPlan);  // Contains activation/deactivation details
      wfVariables.put("approvalScheme", "none");

      // Launch LCM sub-workflow
      WorkflowLaunch wfLaunch = new WorkflowLaunch();
      wfLaunch.setWorkflowName("VF-Core-ActivateDeactivateIdentity-LCMCreateandUpdate");
      wfLaunch.setLauncher(launcher);
      wfLaunch.setVariables(wfVariables);

      Workflower wfr = new Workflower(context);
      WorkflowLaunch wfLaunch1 = wfr.launch(wfLaunch);

      // Extract Request ID from LCM workflow result
      WorkflowCase wfCase = wfLaunch1.getWorkflowCase();
      TaskResult ts = wfCase.getTaskResult();
      String requestID = ts.get("identityRequestId");  // ← THIS IS THE REQUEST ID!

      workflow.put("requestID", requestID);
      requestIds.add(requestID);
    }

    maModel.put("requestIds", String.join(", ", requestIds));
  </Script>
</Step>
```

**KEY INSIGHT**: The Request ID is generated by the **LCM sub-workflow** (`VF-Core-ActivateDeactivateIdentity-LCMCreateandUpdate`), NOT by the main workflow!

---

#### Step 5: Show Summary Form (LINE 437)
```xml
<Step name="Show Summary Form">
  <Approval owner="ref:launcher">
    <Arg name="workItemForm" value="VF-Core-ActivateDeactivateIdentity-RequestView"/>
  </Approval>
```

**What Happens in UI:**
1. Third WorkItem shows summary with Request IDs
2. User reviews and clicks "Done"
3. Workflow completes

---

## Why Programmatic Testing Fails

### Root Causes:

1. **WorkItems Require Servlet Container**
   - `<Approval>` steps create WorkItems using `WorkItemService`
   - `WorkItemService` validates HTTP session exists in servlet container
   - Test code runs **standalone** without Tomcat/servlet container
   - WorkItems created in memory but NOT persisted to database

2. **FacesContext Required**
   - Forms require JSF `FacesContext` for rendering
   - `FacesContext.getCurrentInstance()` returns NULL in test code
   - Form rendering fails → WorkItems not created

3. **HTTP Session Validation**
   - Workflow expects `httpSession` parameter from QuickLink
   - Session must be registered with `HttpSessionRegistry` in servlet container
   - Mock sessions fail validation → Workflow treats WorkItems as transient

4. **Transient Workflow Flag**
   - Line 18: `<Variable initializer="true" name="transient"/>`
   - This marks workflow as non-persistent
   - WorkItems created but not saved to database

---

## What We've Tried (All Failed)

### Attempt 1: Direct Workflow Launch with Form Completion
```java
String workflowCaseId = workflowExecutor.launchWorkflow(WORKFLOW_NAME, launcher, variables);
WorkItem initiateForm = workItemHandler.waitForWorkItem(workflowCaseId, WorkItem.Type.Form, 30);
// RESULT: initiateForm = NULL ❌
```
**Why Failed**: WorkItems not persisted to database

---

### Attempt 2: Mock HTTP Session
```java
HttpSession mockSession = MockHttpSessionProvider.createMockSession(launcher);
variables.put("httpSession", mockSession);
// RESULT: WorkItems still NULL ❌
```
**Why Failed**: Mock session not registered with servlet container

---

### Attempt 3: ServerSideWorkflowLauncher (RequestManager)
```java
RequestManager.addRequest(context, request);
// RESULT: Request queued but WorkItems not created after 60s ❌
```
**Why Failed**: IIQ server's request executor may not be running, or requires additional configuration

---

### Attempt 4: Direct LCM Workflow Call
```java
String lcmWorkflowId = workflowExecutor.launchWorkflow(
    "VF-Core-ActivateDeactivateIdentity-LCMCreateandUpdate",
    launcher,
    lcmVariables
);
// RESULT: Workflow doesn't complete ❌
```
**Why Failed**: LCM workflow expects specific variables/context from main workflow

---

## THE SOLUTION: Bypass the UI Workflow Entirely

Since the UI workflow requires web context, we need to **replicate what the "Build Rio Plan" step does** programmatically.

### Recommended Approach:

Create a **custom test method** that:
1. ✅ Skips the UI forms entirely
2. ✅ Directly creates the provisioning plan
3. ✅ Calls the LCM sub-workflow with correct parameters
4. ✅ Captures the Request ID from the result

---

## Implementation Strategy

### Step-by-Step Solution:

```java
@Test
public void testActivateIdentityProgrammatically() {
    // 1. Define users to activate
    List<String> usersToActivate = Arrays.asList("944D25E7F42C7B46");

    // 2. For each user, create provisioning plan
    for (String userId : usersToActivate) {
        Identity identity = identityService.getIdentity(userId);

        // 3. Create provisioning plan (what "Build Rio Plan" does)
        ProvisioningPlan plan = createActivationPlan(identity);

        // 4. Prepare LCM workflow variables
        Map<String, Object> lcmVars = new HashMap<>();
        lcmVars.put("identityName", userId);
        lcmVars.put("plan", plan);
        lcmVars.put("flow", "Activate");
        lcmVars.put("launcher", LAUNCHER_USER);
        lcmVars.put("approvalScheme", "none");  // No approvals
        lcmVars.put("trace", true);

        // 5. Launch LCM workflow SYNCHRONOUSLY (wait for completion)
        String requestId = launchLCMWorkflowSync(
            "VF-Core-ActivateDeactivateIdentity-LCMCreateandUpdate",
            LAUNCHER_USER,
            lcmVars
        );

        // 6. Validate Request ID
        assertNotNull("Request ID should be generated", requestId);
        logger.info("✓ Request ID: {}", requestId);
    }
}

private ProvisioningPlan createActivationPlan(Identity identity) {
    ProvisioningPlan plan = new ProvisioningPlan();
    plan.setIdentity(identity);

    // Replicate what workflow does at line 300-350
    ProvisioningPlan.AccountRequest acctReq = new ProvisioningPlan.AccountRequest();
    acctReq.setOperation(ProvisioningPlan.AccountRequest.Operation.Modify);
    acctReq.setApplication("IIQ");

    // Set activation attributes
    acctReq.add(new ProvisioningPlan.AttributeRequest("inactive", false));
    acctReq.add(new ProvisioningPlan.AttributeRequest("vf_id_status", "Active Adhoc"));

    plan.add(acctReq);
    return plan;
}

private String launchLCMWorkflowSync(String workflowName, String launcher, Map<String, Object> vars) {
    String caseId = workflowExecutor.launchWorkflow(workflowName, launcher, vars);

    // Wait for completion (synchronous)
    WorkflowCase completedCase = workflowExecutor.waitForCompletion(caseId, 60);

    if (completedCase != null && completedCase.getTaskResult() != null) {
        return (String) completedCase.getTaskResult().get("identityRequestId");
    }

    return null;
}
```

---

## Next Steps

Would you like me to:

1. **Create the complete test class** implementing this approach?
2. **Extract the exact provisioning plan logic** from the workflow script (lines 200-400)?
3. **Create a helper utility** to generate activation/deactivation plans?
4. **Test with your existing user** (944D25E7F42C7B46)?

This approach will **100% bypass the UI** and give you programmatic Request ID generation!
